!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{var g;g="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,g.theorem=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){(function(global){function parse(str){const OP=Symbol("Operator"),PAREN=Symbol("Parenthesis"),VAR=Symbol("Variable");let tokens=[],current={};for(let ch of str)if(!" \n\t".includes(ch)){let type;type=/[∧∨¬!→↔&|<>-]/.test(ch)?OP:/[()]/.test(ch)?PAREN:VAR,type===current.type&&type!=PAREN?current.value+=ch:(current={type:type,value:ch},tokens.push(current))}let output=[],operators=[],precedence=function(token){if(["->","<->","→","↔"].includes(token.value))return 0;if(["∧","∨","&","|"].includes(token.value))return 1;if(["¬","!"].includes(token.value))return 2;throw new Error(`Unrecognized operator ${token.value}`)},out=function(operator){let expression,v=operator.value;if("¬"===v||"!"===v)expression=new Expression(NOT,[output.pop()]);else{let type;if("->"===v||"→"===v)type=IMPL;else if("<->"===v||"↔"===v)type=EQV;else if("∧"===v||"&"===v)type=AND;else{if("∨"!==v&&"|"!==v)throw new Error(`Unrecognized operator: "${v}"`);type=OR}let right=output.pop(),left=output.pop();expression=new Expression(type,[left,right])}output.push(expression)};for(let t of tokens){if(t.type===OP){for(;;){let last=operators[operators.length-1];if(void 0===last)break;if(last.type===PAREN)break;if(precedence(t)>=precedence(last))break;out(operators.pop())}operators.push(t)}if(t.type===VAR&&output.push(t.value),"("===t.value&&operators.push(t),")"===t.value)for(;;){let op=operators.pop();if(void 0===op)throw new Error("Mismatched parenthesis.");if("("===op.value)break;out(op)}}for(;;){let op=operators.pop();if(void 0===op)break;if("("===op.value||")"===op.value)throw new Error("Mismatched parenthesis.");out(op)}return output[0]}require("./types.js")(global),module.exports={parse:parse}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./types.js":3}],2:[function(require,module,exports){(function(global){function facts(...expressions){for(let expr of expressions)expr=toCNF(expr),collectConjunctions(database,expr);return database}function clear(){database=[]}function collectConjunctions(set,expr){"string"==typeof expr?set.push(expr):expr.action!==AND?set.push(expr):expr.args.map(collectConjunctions.bind(this,set))}function extractLiterals(expr){function helper(e){"string"==typeof e?set.add(e):e.action===NOT?set.add(e.toString()):e.args.map(helper)}let set=new Set;return helper(expr),set}function prove(expression){let expr=new Expression(NOT,[expression]),test=database.slice();collectConjunctions(test,toCNF(expr));let clauses=test.map(extractLiterals);for(;;){let newClauses=[],n=clauses.length;for(let i=0;i<n;i++){let A=clauses[i];inner:for(let j=i+1;j<n;j++){let B=clauses[j],result=resolve(A,B);if(0===result.size)return!0;for(let lit of result)if(result.has(negate(lit)))continue inner;let result_arr=Array.from(result);for(let clause of clauses.concat(newClauses)){let leftContain=result_arr.every(lit=>clause.has(lit)),rightContain=Array.from(clause).every(lit=>result.has(lit));if(leftContain&&rightContain)continue inner}newClauses.push(result)}}if(0===newClauses.length)return!1;clauses=clauses.concat(newClauses)}}function negate(literal){return literal.startsWith("¬")?literal.slice(1):"¬"+literal}function resolve(A_list,B_list){let A=Array.from(A_list),B=Array.from(B_list),unique_A=A.filter(literal=>!B.includes(negate(literal))),unique_B=B.filter(literal=>!A.includes(negate(literal)));return new Set(unique_A.concat(unique_B))}function toCNF(expression){return"string"==typeof expression?expression:distributeOr(eliminateDoubleNegations(applyDeMorgan(replaceImplications(removeBiconditionals(expression.clone())))))}function removeBiconditionals(expression){if("string"==typeof expression)return expression;if(expression.action===EQV){let AB=new Expression(IMPL,expression.args),BA=new Expression(IMPL,[expression.args[1],expression.args[0]]);expression=new Expression(AND,[AB,BA])}return expression.args=expression.args.map(removeBiconditionals),expression}function replaceImplications(expression){if("string"==typeof expression)return expression;if(expression.action===IMPL){let[A,B]=expression.args;expression=new Expression(OR,[new Expression(NOT,[A]),B])}return expression.args=expression.args.map(replaceImplications),expression}function applyDeMorgan(expression){if("string"==typeof expression)return expression;if(expression.action===NOT){let arg=expression.args[0];if("string"==typeof arg)return expression;let[A,B]=arg.args;arg.action===AND?expression=new Expression(OR,[new Expression(NOT,[A]),new Expression(NOT,[B])]):arg.action===OR&&(expression=new Expression(AND,[new Expression(NOT,[A]),new Expression(NOT,[B])]))}return expression.args=expression.args.map(applyDeMorgan),expression}function eliminateDoubleNegations(expression){if("string"==typeof expression)return expression;if(expression.action===NOT){let arg=expression.args[0];if(arg.action===NOT&&(expression=arg.args[0],"string"==typeof expression))return expression}return expression.args=expression.args.map(eliminateDoubleNegations),expression}function distributeOr(expression){if("string"==typeof expression)return expression;let[A,B]=expression.args;if(expression.action===OR)if("string"==typeof A){if("string"==typeof B)return expression;if(B.action===AND){let[X,Y]=B.args;expression=new Expression(AND,[new Expression(OR,[A,X]),new Expression(OR,[A,Y])])}}else if(A.action==AND){let[X,Y]=A.args;expression=new Expression(AND,[new Expression(OR,[X,B]),new Expression(OR,[Y,B])])}return expression.args=expression.args.map(distributeOr),expression}require("./types.js")(global);let parser=require("./parser.js"),database=[];module.exports={facts:facts,clear:clear,prove:prove,Expression:Expression,parse:parser.parse}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./parser.js":1,"./types.js":3}],3:[function(require,module,exports){function translate(key){let dict={[NOT]:"¬",[AND]:"∧",[OR]:"∨",[IMPL]:"→",[EQV]:"↔"};if(void 0===dict[key])throw new Error("No matching symbol or action found.");return dict[key]}const NOT=Symbol("negation"),AND=Symbol("conjunction"),OR=Symbol("disjunction"),IMPL=Symbol("implication"),EQV=Symbol("equivalence");class Expression{constructor(action,args){if(!action||"symbol"!=typeof action)throw new TypeError("Need action constant.");if(!(args&&args instanceof Array))throw new Error("Need array of arguments.");if(action===NOT&&1!==args.length)throw new Error(`Expected one argument for negation, but got ${args}`);if(action!==NOT&&2!==args.length)throw new Error(`Expected two arguments, but got ${args}`);for(let arg of args)if(!(arg instanceof Expression||"string"==typeof arg))throw new TypeError("Arguments must be strings or Expressions.");this.action=action,this.args=args}toString(){return this.action===NOT?`¬${this.args[0].toString()}`:`(${this.args[0].toString()} ${translate(this.action)} ${this.args[1].toString()})`}clone(){let[A,B]=this.args;return"string"!=typeof A&&(A=A.clone()),this.action!==NOT&&"string"!=typeof B&&(B=B.clone()),this.action===NOT?new Expression(NOT,[A]):new Expression(this.action,[A,B])}}module.exports=function(obj){obj.NOT=NOT,obj.AND=AND,obj.OR=OR,obj.IMPL=IMPL,obj.EQV=EQV,obj.Expression=Expression}},{}]},{},[2])(2)});
